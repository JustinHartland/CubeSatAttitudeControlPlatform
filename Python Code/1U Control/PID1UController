import time
import board
import busio
import adafruit_lsm9ds1
import odrive
import math
from odrive.enums import *
from simple_pid import PID

# Find a connected ODrive (this will block until you connect one)
print("finding an odrive...")
my_drive = odrive.find_any()

# Calibrate motor and wait for it to finish
print("starting calibration...")
my_drive.axis0.requested_state = AXIS_STATE_FULL_CALIBRATION_SEQUENCE
while my_drive.axis0.current_state != AXIS_STATE_IDLE:
    time.sleep(0.1)

my_drive.axis0.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL
#my_drive.axis0.controller.config.control_mode = CONTROL_MODE_VELOCITY_CONTROL
my_drive.axis0.controller.config.control_mode = CONTROL_MODE_TORQUE_CONTROL
my_drive.axis0.controller.config.torque_constant = 8.23 / 150

# Initialize I2C bus and sensor
i2c = board.I2C()
sensor = adafruit_lsm9ds1.LSM9DS1_I2C(i2c)

# Initial angular positions
previousAngleZ = 0

# Time initialization
prev_Time = time.time()

#PID Controller Setup
targetAngle = 0                                     #Set target orientation angle here
pid = PID(-0.03, 0, 0, setpoint = targetAngle)       #Configure PID constants, and target
pid.output_limits = (-20, 20)                          #Set limits on torque

def getOrientationAngles(currentTime, previousTime, previousAngleZ):
    # Get the current time and compute the elapsed time
    dt = currentTime - previousTime

    # Read gyroscope values (assumed to be in degrees per second)
    gyro_x, gyro_y, gyro_z = sensor.gyro

    # Integrate gyro values to get angular positions
    angle_z = previousAngleZ + (gyro_z * dt) * (180/math.pi) #degrees

    # Print angular positions
    print(f'Angle Z: {angle_z:.2f}')

    return angle_z

try:
    while True:
        curr_Time = time.time()

        angle_z = getOrientationAngles(curr_Time, prev_Time, previousAngleZ)

        #Set control velocity
        controlTorque = pid(angle_z)

        #Set motor current to control torque
        my_drive.axis0.controller.input_torque = controlTorque

        # Update the previous time for the next iteration
        prev_Time = curr_Time
        previousAngleZ = angle_z

        #Print motor velocity
        motorVelocity = my_drive.encoder.vel.estimate
        print(f'Current velocity: {motorVelocity}')

        # Sleep for a while to reduce the update rate
        time.sleep(0.01)

except KeyboardInterrupt:
    pass

my_drive.axis0.controller.config.control_mode = CONTROL_MODE_VELOCITY_CONTROL
my_drive.axis0.controller.input_vel(0)